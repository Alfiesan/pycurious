<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>pycurious.therm API documentation</title>
<meta name="description" content="Copyright 2018 Ben Mather, Robert Delhaye â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycurious.therm</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2018 Ben Mather, Robert Delhaye</p>
<p>This file is part of PyCurious.</p>
<p>PyCurious is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>PyCurious is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with PyCurious.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2018 Ben Mather, Robert Delhaye

This file is part of PyCurious.

PyCurious is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

PyCurious is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with PyCurious.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

import numpy as np
from scipy import sparse
from scipy.sparse.linalg import spsolve
from multiprocessing import Pool, Process, Queue, cpu_count

try: range=xrange
except: pass


class CurieTherm(object):
    &#34;&#34;&#34;
    Implicit 1d solver for the steady-state heat equation
    over a structured grid using sparse matrices.

    Parameters
    ----------
     minZ : float, minimum Cartesian coordinate
     maxZ : float, maximum Cartesian coordinate
     resZ : int, resolution in the z direction
     kwargs : dict, keyword arguments to pass to control
       optional functionality e.g.
       - stencil_width=int : number of node neighbours to
           include in each matrix row

    Attributes
    ----------
     diffusivity  : float shape(n,) thermal conductivity field
     heat_sources : float shape(n,) heat source field
     temperature  : float shape(n,) temperature field

     npoints      : int, number of nodes in the mesh
     sizes        : (int,int) dimensions of the sparse matrix
     
    &#34;&#34;&#34;

    def __init__(self, minZ, maxZ, resZ, **kwargs):

        self.npoints = resZ
        self.extent = (minZ, maxZ)
        self.coords = np.linspace(minZ, maxZ, resZ)
        self.nodes = np.arange(0, resZ, dtype=np.int)
        self.sizes = (resZ, resZ)

        width = kwargs.pop(&#39;stencil_width&#39;, 1)
        self.stencil_width = 2*width + 1

        closure = [(0,-2), (2,0), (1,-1)]
        self.closure = self._create_closure_object(closure)


        self._initialise_COO_vectors()
        self._initialise_boundary_dictionary()
        self.diffusivity  = np.zeros(resZ)
        self.heat_sources = np.zeros(resZ)
        self.temperature  = np.zeros(resZ)


    def _initialise_COO_vectors(self):

        nn = self.npoints

        index = np.empty(nn + 2, dtype=np.int)
        index.fill(-1)
        self.index = index

        self.rows = np.empty((self.stencil_width, nn), dtype=np.int)
        self.cols = np.empty((self.stencil_width, nn), dtype=np.int)
        self.vals = np.empty((self.stencil_width, nn))


    def _initialise_boundary_dictionary(self):

        nn = self.npoints
        coords = self.coords
        minZ, maxZ = self.extent

        # Setup boundary dictionary
        bc = dict()

        m0 = coords == minZ
        m1 = coords == maxZ
        d0 = abs(coords[1] - coords[0])
        d1 = abs(coords[-1] - coords[-2])

        bc[&#34;minZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d0, &#34;flux&#34;: True, &#34;mask&#34;: m0}
        bc[&#34;maxZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d1, &#34;flux&#34;: True, &#34;mask&#34;: m1}

        self.bc = bc
        self.dirichlet_mask = np.zeros(nn, dtype=bool)


    def _create_closure_object(self, closure):

        nn = self.npoints
        obj = [[0] for i in range(self.stencil_width)]

        for i in range(0, self.stencil_width):
            # construct slicing object
            start, end = closure[i-j]
            obj[i] = slice(start, nn+end+2)

        return obj


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;
        self.diffusivity[:] = diffusivity
        self.heat_sources[:] = heat_sources
        return


    def boundary_condition(self, wall, val, flux=False):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Dirichlet condition.

        Parameters
        ----------
         wall : str, wall to assign bc - &#39;minZ&#39; or &#39;maxZ&#39;
         val  : float or array(n,) value(s) to assign to wall
         flux : bool, toggle type of boundary condition
           True = Neumann flux boundary condition
           False = Dirichlet boundary condition (default)

        Notes
        -----
         If flux=True, positive val indicates a flux vector towards the centre
         of the domain.

         val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;
        wall = str(wall)

        if wall in self.bc:
            self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
            self.bc[wall][&#34;flux&#34;] = flux
            d = self.bc[wall]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False
                self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))


    def construct_matrix(self):
        &#34;&#34;&#34;
        Construct a sparse coefficient matrix
        i.e. matrix A in AT = b

        Notes
        -----
         We vectorise the 7-point stencil for fast matrix insertion.
         An extra border of dummy values around the domain allows for automatic
         Neumann (flux) boundary creation.
         These are stomped on if there are any Dirichlet conditions.
        &#34;&#34;&#34;

        nodes = self.nodes
        nn = self.npoints

        index = self.index

        rows = self.rows
        cols = self.cols
        vals = self.vals

        dirichlet_mask = self.dirichlet_mask
        coords = self.coords.reshape(-1,1)

        u = self.diffusivity

        k = np.zeros(nn + 2)
        k[1:-1] = u

        for i in range(0, self.stencil_width):
            obj = self.closure[i]

            rows[i] = nodes
            cols[i] = index[obj].ravel()

            distance = np.linalg.norm(coords[cols[i]] - coords, axis=1)
            distance[distance==0] = 1e-12 # protect against dividing by zero
            delta = 1.0/(2.0*distance**2)

            vals[i] = delta*(k[obj] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt;= 0
        row = row[mask]
        col = col[mask]
        val = val[mask]

        mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
        mat.sum_duplicates()
        diag = np.ravel(mat.sum(axis=1))
        diag *= -1
        mat.setdiag(diag)

        return mat


    def construct_rhs(self):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in AT = b

        Notes
        -----
         Boundary conditions are grabbed from the dictionary and
         summed to the rhs.
         Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        
        rhs = -1.0*self.heat_sources

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                rhs[mask] += val
            else:
                rhs[mask] = val

        return rhs


    def solve(self, matrix=None, rhs=None):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in AT = b and solve for T
        (i.e. temperature field)

        Arguments
        ---------
         matrix : (optional) scipy sparse matrix object
                 build using construct_matrix()
         rhs    : (optional) numpy right-hand-side vector
                 build using construct_rhs()

        Returns
        -------
         sol    : 1d array shape(n,) temperature solution

        Notes
        -----
         The solution to the system of linear equations AT = b is solved
         with spsolve in the scipy.sparse.linalg module
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.construct_matrix()
        if rhs is None:
            rhs = self.construct_rhs()
        # res = self.temperature

        T = spsolve(matrix, rhs)
        self.temperature[:] = T

        return T


    def gradient(self, vector, **kwargs):
        &#34;&#34;&#34;
        Calculate gradient of a vector
        
        Arguments
        ---------
         vector : 1d array of shape(n,)

        Returns
        -------
         dvdz   : 1d array of shape(n,)
                 derivative of vector in z direction
        &#34;&#34;&#34;
        return np.gradient(vector, self.coords, **kwargs)


    def heatflux(self):
        &#34;&#34;&#34;
        Calculate the heat flux from the conductivity field
        and temperature solution

        Returns
        -------
         qz  : 1d array shape(n,) heat flux vector
        &#34;&#34;&#34;

        T = self.temperature
        k = self.diffusivity
        divT = self.gradient(T)
        return -k*divT


    def isosurface(self, vector, isoval, interp=&#39;linear&#39;):
        &#34;&#34;&#34;
        Calculate an isosurface along the z axis

        Parameters
        ----------
         vector : array, the same size as the mesh (n,)
         isoval : float, isosurface value
         interp : str, interpolation method can be either
            &#39;nearest&#39; - nearest neighbour interpolation
            &#39;linear&#39;  - linear interpolation
        
        Returns
        -------
         z_interp : isosurface
        &#34;&#34;&#34;
        coords = self.coords
        sort_idx = np.abs(vector - isoval).argsort()    
        i0 = sort_idx[0]
        z0 = coords[i0]

        if interp == &#39;linear&#39;:
            v0 = vector[i0]
            
            # identify next nearest node
            i1 = sort_idx[1]
            z1 = coords[i1]
            v1 = vector[i1]

            vmin = min(v0,v1)
            vmax = max(v0,v1)

            ratio = np.array([isoval, vmin, vmax])
            ratio -= ratio.min()
            ratio /= ratio.max()
            z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
            return z_interp
        elif interp == &#39;nearest&#39;:
            return z0
        else:
            raise ValueError(&#34;enter a valid interp method: &#39;linear&#39; or &#39;nearest&#39;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycurious.therm.CurieTherm"><code class="flex name class">
<span>class <span class="ident">CurieTherm</span></span>
<span>(</span><span>minZ, maxZ, resZ, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Implicit 1d solver for the steady-state heat equation
over a structured grid using sparse matrices.</p>
<h2 id="parameters">Parameters</h2>
<p>minZ : float, minimum Cartesian coordinate
maxZ : float, maximum Cartesian coordinate
resZ : int, resolution in the z direction
kwargs : dict, keyword arguments to pass to control
optional functionality e.g.
- stencil_width=int : number of node neighbours to
include in each matrix row</p>
<h2 id="attributes">Attributes</h2>
<p>diffusivity
: float shape(n,) thermal conductivity field
heat_sources : float shape(n,) heat source field
temperature
: float shape(n,) temperature field</p>
<p>npoints
: int, number of nodes in the mesh
sizes
: (int,int) dimensions of the sparse matrix</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CurieTherm(object):
    &#34;&#34;&#34;
    Implicit 1d solver for the steady-state heat equation
    over a structured grid using sparse matrices.

    Parameters
    ----------
     minZ : float, minimum Cartesian coordinate
     maxZ : float, maximum Cartesian coordinate
     resZ : int, resolution in the z direction
     kwargs : dict, keyword arguments to pass to control
       optional functionality e.g.
       - stencil_width=int : number of node neighbours to
           include in each matrix row

    Attributes
    ----------
     diffusivity  : float shape(n,) thermal conductivity field
     heat_sources : float shape(n,) heat source field
     temperature  : float shape(n,) temperature field

     npoints      : int, number of nodes in the mesh
     sizes        : (int,int) dimensions of the sparse matrix
     
    &#34;&#34;&#34;

    def __init__(self, minZ, maxZ, resZ, **kwargs):

        self.npoints = resZ
        self.extent = (minZ, maxZ)
        self.coords = np.linspace(minZ, maxZ, resZ)
        self.nodes = np.arange(0, resZ, dtype=np.int)
        self.sizes = (resZ, resZ)

        width = kwargs.pop(&#39;stencil_width&#39;, 1)
        self.stencil_width = 2*width + 1

        closure = [(0,-2), (2,0), (1,-1)]
        self.closure = self._create_closure_object(closure)


        self._initialise_COO_vectors()
        self._initialise_boundary_dictionary()
        self.diffusivity  = np.zeros(resZ)
        self.heat_sources = np.zeros(resZ)
        self.temperature  = np.zeros(resZ)


    def _initialise_COO_vectors(self):

        nn = self.npoints

        index = np.empty(nn + 2, dtype=np.int)
        index.fill(-1)
        self.index = index

        self.rows = np.empty((self.stencil_width, nn), dtype=np.int)
        self.cols = np.empty((self.stencil_width, nn), dtype=np.int)
        self.vals = np.empty((self.stencil_width, nn))


    def _initialise_boundary_dictionary(self):

        nn = self.npoints
        coords = self.coords
        minZ, maxZ = self.extent

        # Setup boundary dictionary
        bc = dict()

        m0 = coords == minZ
        m1 = coords == maxZ
        d0 = abs(coords[1] - coords[0])
        d1 = abs(coords[-1] - coords[-2])

        bc[&#34;minZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d0, &#34;flux&#34;: True, &#34;mask&#34;: m0}
        bc[&#34;maxZ&#34;] = {&#34;val&#34;: 0.0, &#34;delta&#34;: d1, &#34;flux&#34;: True, &#34;mask&#34;: m1}

        self.bc = bc
        self.dirichlet_mask = np.zeros(nn, dtype=bool)


    def _create_closure_object(self, closure):

        nn = self.npoints
        obj = [[0] for i in range(self.stencil_width)]

        for i in range(0, self.stencil_width):
            # construct slicing object
            start, end = closure[i-j]
            obj[i] = slice(start, nn+end+2)

        return obj


    def update_properties(self, diffusivity, heat_sources):
        &#34;&#34;&#34;
        Update diffusivity and heat sources
        &#34;&#34;&#34;
        self.diffusivity[:] = diffusivity
        self.heat_sources[:] = heat_sources
        return


    def boundary_condition(self, wall, val, flux=False):
        &#34;&#34;&#34;
        Set the boundary conditions on each wall of the domain.
        By default each wall is a Dirichlet condition.

        Parameters
        ----------
         wall : str, wall to assign bc - &#39;minZ&#39; or &#39;maxZ&#39;
         val  : float or array(n,) value(s) to assign to wall
         flux : bool, toggle type of boundary condition
           True = Neumann flux boundary condition
           False = Dirichlet boundary condition (default)

        Notes
        -----
         If flux=True, positive val indicates a flux vector towards the centre
         of the domain.

         val can be a vector with the same number of elements as the wall
        &#34;&#34;&#34;
        wall = str(wall)

        if wall in self.bc:
            self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
            self.bc[wall][&#34;flux&#34;] = flux
            d = self.bc[wall]

            mask = d[&#39;mask&#39;]

            if flux:
                self.dirichlet_mask[mask] = False
                self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
            else:
                self.dirichlet_mask[mask] = True

        else:
            raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))


    def construct_matrix(self):
        &#34;&#34;&#34;
        Construct a sparse coefficient matrix
        i.e. matrix A in AT = b

        Notes
        -----
         We vectorise the 7-point stencil for fast matrix insertion.
         An extra border of dummy values around the domain allows for automatic
         Neumann (flux) boundary creation.
         These are stomped on if there are any Dirichlet conditions.
        &#34;&#34;&#34;

        nodes = self.nodes
        nn = self.npoints

        index = self.index

        rows = self.rows
        cols = self.cols
        vals = self.vals

        dirichlet_mask = self.dirichlet_mask
        coords = self.coords.reshape(-1,1)

        u = self.diffusivity

        k = np.zeros(nn + 2)
        k[1:-1] = u

        for i in range(0, self.stencil_width):
            obj = self.closure[i]

            rows[i] = nodes
            cols[i] = index[obj].ravel()

            distance = np.linalg.norm(coords[cols[i]] - coords, axis=1)
            distance[distance==0] = 1e-12 # protect against dividing by zero
            delta = 1.0/(2.0*distance**2)

            vals[i] = delta*(k[obj] + u).ravel()


        # Dirichlet boundary conditions (duplicates are summed)
        cols[:,dirichlet_mask] = nodes[dirichlet_mask]
        vals[:,dirichlet_mask] = 0.0

        # zero off-grid coordinates
        vals[cols &lt; 0] = 0.0

        # centre point
        vals[-1] = 0.0
        vals[-1][dirichlet_mask] = -1.0


        row = rows.ravel()
        col = cols.ravel()
        val = vals.ravel()


        # mask off-grid entries and sum duplicates
        mask = col &gt;= 0
        row = row[mask]
        col = col[mask]
        val = val[mask]

        mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
        mat.sum_duplicates()
        diag = np.ravel(mat.sum(axis=1))
        diag *= -1
        mat.setdiag(diag)

        return mat


    def construct_rhs(self):
        &#34;&#34;&#34;
        Construct the right-hand-side vector
        i.e. vector b in AT = b

        Notes
        -----
         Boundary conditions are grabbed from the dictionary and
         summed to the rhs.
         Be careful of duplicate entries on the corners!!
        &#34;&#34;&#34;
        
        rhs = -1.0*self.heat_sources

        for wall in self.bc:
            val  = self.bc[wall][&#39;val&#39;]
            flux = self.bc[wall][&#39;flux&#39;]
            mask = self.bc[wall][&#39;mask&#39;]
            if flux:
                rhs[mask] += val
            else:
                rhs[mask] = val

        return rhs


    def solve(self, matrix=None, rhs=None):
        &#34;&#34;&#34;
        Construct the matrix A and vector b in AT = b and solve for T
        (i.e. temperature field)

        Arguments
        ---------
         matrix : (optional) scipy sparse matrix object
                 build using construct_matrix()
         rhs    : (optional) numpy right-hand-side vector
                 build using construct_rhs()

        Returns
        -------
         sol    : 1d array shape(n,) temperature solution

        Notes
        -----
         The solution to the system of linear equations AT = b is solved
         with spsolve in the scipy.sparse.linalg module
        &#34;&#34;&#34;
        if matrix is None:
            matrix = self.construct_matrix()
        if rhs is None:
            rhs = self.construct_rhs()
        # res = self.temperature

        T = spsolve(matrix, rhs)
        self.temperature[:] = T

        return T


    def gradient(self, vector, **kwargs):
        &#34;&#34;&#34;
        Calculate gradient of a vector
        
        Arguments
        ---------
         vector : 1d array of shape(n,)

        Returns
        -------
         dvdz   : 1d array of shape(n,)
                 derivative of vector in z direction
        &#34;&#34;&#34;
        return np.gradient(vector, self.coords, **kwargs)


    def heatflux(self):
        &#34;&#34;&#34;
        Calculate the heat flux from the conductivity field
        and temperature solution

        Returns
        -------
         qz  : 1d array shape(n,) heat flux vector
        &#34;&#34;&#34;

        T = self.temperature
        k = self.diffusivity
        divT = self.gradient(T)
        return -k*divT


    def isosurface(self, vector, isoval, interp=&#39;linear&#39;):
        &#34;&#34;&#34;
        Calculate an isosurface along the z axis

        Parameters
        ----------
         vector : array, the same size as the mesh (n,)
         isoval : float, isosurface value
         interp : str, interpolation method can be either
            &#39;nearest&#39; - nearest neighbour interpolation
            &#39;linear&#39;  - linear interpolation
        
        Returns
        -------
         z_interp : isosurface
        &#34;&#34;&#34;
        coords = self.coords
        sort_idx = np.abs(vector - isoval).argsort()    
        i0 = sort_idx[0]
        z0 = coords[i0]

        if interp == &#39;linear&#39;:
            v0 = vector[i0]
            
            # identify next nearest node
            i1 = sort_idx[1]
            z1 = coords[i1]
            v1 = vector[i1]

            vmin = min(v0,v1)
            vmax = max(v0,v1)

            ratio = np.array([isoval, vmin, vmax])
            ratio -= ratio.min()
            ratio /= ratio.max()
            z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
            return z_interp
        elif interp == &#39;nearest&#39;:
            return z0
        else:
            raise ValueError(&#34;enter a valid interp method: &#39;linear&#39; or &#39;nearest&#39;&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycurious.therm.CurieTherm.boundary_condition"><code class="name flex">
<span>def <span class="ident">boundary_condition</span></span>(<span>self, wall, val, flux=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the boundary conditions on each wall of the domain.
By default each wall is a Dirichlet condition.</p>
<h2 id="parameters">Parameters</h2>
<p>wall : str, wall to assign bc - 'minZ' or 'maxZ'
val
: float or array(n,) value(s) to assign to wall
flux : bool, toggle type of boundary condition
True = Neumann flux boundary condition
False = Dirichlet boundary condition (default)</p>
<h2 id="notes">Notes</h2>
<p>If flux=True, positive val indicates a flux vector towards the centre
of the domain.</p>
<p>val can be a vector with the same number of elements as the wall</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def boundary_condition(self, wall, val, flux=False):
    &#34;&#34;&#34;
    Set the boundary conditions on each wall of the domain.
    By default each wall is a Dirichlet condition.

    Parameters
    ----------
     wall : str, wall to assign bc - &#39;minZ&#39; or &#39;maxZ&#39;
     val  : float or array(n,) value(s) to assign to wall
     flux : bool, toggle type of boundary condition
       True = Neumann flux boundary condition
       False = Dirichlet boundary condition (default)

    Notes
    -----
     If flux=True, positive val indicates a flux vector towards the centre
     of the domain.

     val can be a vector with the same number of elements as the wall
    &#34;&#34;&#34;
    wall = str(wall)

    if wall in self.bc:
        self.bc[wall][&#34;val&#34;]  = np.array(val, copy=True)
        self.bc[wall][&#34;flux&#34;] = flux
        d = self.bc[wall]

        mask = d[&#39;mask&#39;]

        if flux:
            self.dirichlet_mask[mask] = False
            self.bc[wall][&#34;val&#34;] /= -d[&#39;delta&#39;]
        else:
            self.dirichlet_mask[mask] = True

    else:
        raise ValueError(&#34;Wall should be one of {}&#34;.format(self.bc.keys()))</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.construct_matrix"><code class="name flex">
<span>def <span class="ident">construct_matrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct a sparse coefficient matrix
i.e. matrix A in AT = b</p>
<h2 id="notes">Notes</h2>
<p>We vectorise the 7-point stencil for fast matrix insertion.
An extra border of dummy values around the domain allows for automatic
Neumann (flux) boundary creation.
These are stomped on if there are any Dirichlet conditions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def construct_matrix(self):
    &#34;&#34;&#34;
    Construct a sparse coefficient matrix
    i.e. matrix A in AT = b

    Notes
    -----
     We vectorise the 7-point stencil for fast matrix insertion.
     An extra border of dummy values around the domain allows for automatic
     Neumann (flux) boundary creation.
     These are stomped on if there are any Dirichlet conditions.
    &#34;&#34;&#34;

    nodes = self.nodes
    nn = self.npoints

    index = self.index

    rows = self.rows
    cols = self.cols
    vals = self.vals

    dirichlet_mask = self.dirichlet_mask
    coords = self.coords.reshape(-1,1)

    u = self.diffusivity

    k = np.zeros(nn + 2)
    k[1:-1] = u

    for i in range(0, self.stencil_width):
        obj = self.closure[i]

        rows[i] = nodes
        cols[i] = index[obj].ravel()

        distance = np.linalg.norm(coords[cols[i]] - coords, axis=1)
        distance[distance==0] = 1e-12 # protect against dividing by zero
        delta = 1.0/(2.0*distance**2)

        vals[i] = delta*(k[obj] + u).ravel()


    # Dirichlet boundary conditions (duplicates are summed)
    cols[:,dirichlet_mask] = nodes[dirichlet_mask]
    vals[:,dirichlet_mask] = 0.0

    # zero off-grid coordinates
    vals[cols &lt; 0] = 0.0

    # centre point
    vals[-1] = 0.0
    vals[-1][dirichlet_mask] = -1.0


    row = rows.ravel()
    col = cols.ravel()
    val = vals.ravel()


    # mask off-grid entries and sum duplicates
    mask = col &gt;= 0
    row = row[mask]
    col = col[mask]
    val = val[mask]

    mat = sparse.coo_matrix((val, (row, col)), shape=self.sizes).tocsr()
    mat.sum_duplicates()
    diag = np.ravel(mat.sum(axis=1))
    diag *= -1
    mat.setdiag(diag)

    return mat</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.construct_rhs"><code class="name flex">
<span>def <span class="ident">construct_rhs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct the right-hand-side vector
i.e. vector b in AT = b</p>
<h2 id="notes">Notes</h2>
<p>Boundary conditions are grabbed from the dictionary and
summed to the rhs.
Be careful of duplicate entries on the corners!!</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def construct_rhs(self):
    &#34;&#34;&#34;
    Construct the right-hand-side vector
    i.e. vector b in AT = b

    Notes
    -----
     Boundary conditions are grabbed from the dictionary and
     summed to the rhs.
     Be careful of duplicate entries on the corners!!
    &#34;&#34;&#34;
    
    rhs = -1.0*self.heat_sources

    for wall in self.bc:
        val  = self.bc[wall][&#39;val&#39;]
        flux = self.bc[wall][&#39;flux&#39;]
        mask = self.bc[wall][&#39;mask&#39;]
        if flux:
            rhs[mask] += val
        else:
            rhs[mask] = val

    return rhs</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.gradient"><code class="name flex">
<span>def <span class="ident">gradient</span></span>(<span>self, vector, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate gradient of a vector</p>
<h2 id="arguments">Arguments</h2>
<p>vector : 1d array of shape(n,)</p>
<h2 id="returns">Returns</h2>
<p>dvdz
: 1d array of shape(n,)
derivative of vector in z direction</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def gradient(self, vector, **kwargs):
    &#34;&#34;&#34;
    Calculate gradient of a vector
    
    Arguments
    ---------
     vector : 1d array of shape(n,)

    Returns
    -------
     dvdz   : 1d array of shape(n,)
             derivative of vector in z direction
    &#34;&#34;&#34;
    return np.gradient(vector, self.coords, **kwargs)</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.heatflux"><code class="name flex">
<span>def <span class="ident">heatflux</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the heat flux from the conductivity field
and temperature solution</p>
<h2 id="returns">Returns</h2>
<p>qz
: 1d array shape(n,) heat flux vector</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def heatflux(self):
    &#34;&#34;&#34;
    Calculate the heat flux from the conductivity field
    and temperature solution

    Returns
    -------
     qz  : 1d array shape(n,) heat flux vector
    &#34;&#34;&#34;

    T = self.temperature
    k = self.diffusivity
    divT = self.gradient(T)
    return -k*divT</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.isosurface"><code class="name flex">
<span>def <span class="ident">isosurface</span></span>(<span>self, vector, isoval, interp='linear')</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate an isosurface along the z axis</p>
<h2 id="parameters">Parameters</h2>
<p>vector : array, the same size as the mesh (n,)
isoval : float, isosurface value
interp : str, interpolation method can be either
'nearest' - nearest neighbour interpolation
'linear'
- linear interpolation</p>
<h2 id="returns">Returns</h2>
<p>z_interp : isosurface</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def isosurface(self, vector, isoval, interp=&#39;linear&#39;):
    &#34;&#34;&#34;
    Calculate an isosurface along the z axis

    Parameters
    ----------
     vector : array, the same size as the mesh (n,)
     isoval : float, isosurface value
     interp : str, interpolation method can be either
        &#39;nearest&#39; - nearest neighbour interpolation
        &#39;linear&#39;  - linear interpolation
    
    Returns
    -------
     z_interp : isosurface
    &#34;&#34;&#34;
    coords = self.coords
    sort_idx = np.abs(vector - isoval).argsort()    
    i0 = sort_idx[0]
    z0 = coords[i0]

    if interp == &#39;linear&#39;:
        v0 = vector[i0]
        
        # identify next nearest node
        i1 = sort_idx[1]
        z1 = coords[i1]
        v1 = vector[i1]

        vmin = min(v0,v1)
        vmax = max(v0,v1)

        ratio = np.array([isoval, vmin, vmax])
        ratio -= ratio.min()
        ratio /= ratio.max()
        z_interp = ratio[0]*z1 + (1.0 - ratio[0])*z0
        return z_interp
    elif interp == &#39;nearest&#39;:
        return z0
    else:
        raise ValueError(&#34;enter a valid interp method: &#39;linear&#39; or &#39;nearest&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, matrix=None, rhs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Construct the matrix A and vector b in AT = b and solve for T
(i.e. temperature field)</p>
<h2 id="arguments">Arguments</h2>
<p>matrix : (optional) scipy sparse matrix object
build using construct_matrix()
rhs
: (optional) numpy right-hand-side vector
build using construct_rhs()</p>
<h2 id="returns">Returns</h2>
<p>sol
: 1d array shape(n,) temperature solution</p>
<h2 id="notes">Notes</h2>
<p>The solution to the system of linear equations AT = b is solved
with spsolve in the scipy.sparse.linalg module</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def solve(self, matrix=None, rhs=None):
    &#34;&#34;&#34;
    Construct the matrix A and vector b in AT = b and solve for T
    (i.e. temperature field)

    Arguments
    ---------
     matrix : (optional) scipy sparse matrix object
             build using construct_matrix()
     rhs    : (optional) numpy right-hand-side vector
             build using construct_rhs()

    Returns
    -------
     sol    : 1d array shape(n,) temperature solution

    Notes
    -----
     The solution to the system of linear equations AT = b is solved
     with spsolve in the scipy.sparse.linalg module
    &#34;&#34;&#34;
    if matrix is None:
        matrix = self.construct_matrix()
    if rhs is None:
        rhs = self.construct_rhs()
    # res = self.temperature

    T = spsolve(matrix, rhs)
    self.temperature[:] = T

    return T</code></pre>
</details>
</dd>
<dt id="pycurious.therm.CurieTherm.update_properties"><code class="name flex">
<span>def <span class="ident">update_properties</span></span>(<span>self, diffusivity, heat_sources)</span>
</code></dt>
<dd>
<section class="desc"><p>Update diffusivity and heat sources</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_properties(self, diffusivity, heat_sources):
    &#34;&#34;&#34;
    Update diffusivity and heat sources
    &#34;&#34;&#34;
    self.diffusivity[:] = diffusivity
    self.heat_sources[:] = heat_sources
    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycurious" href="index.html">pycurious</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycurious.therm.CurieTherm" href="#pycurious.therm.CurieTherm">CurieTherm</a></code></h4>
<ul class="two-column">
<li><code><a title="pycurious.therm.CurieTherm.boundary_condition" href="#pycurious.therm.CurieTherm.boundary_condition">boundary_condition</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.construct_matrix" href="#pycurious.therm.CurieTherm.construct_matrix">construct_matrix</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.construct_rhs" href="#pycurious.therm.CurieTherm.construct_rhs">construct_rhs</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.gradient" href="#pycurious.therm.CurieTherm.gradient">gradient</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.heatflux" href="#pycurious.therm.CurieTherm.heatflux">heatflux</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.isosurface" href="#pycurious.therm.CurieTherm.isosurface">isosurface</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.solve" href="#pycurious.therm.CurieTherm.solve">solve</a></code></li>
<li><code><a title="pycurious.therm.CurieTherm.update_properties" href="#pycurious.therm.CurieTherm.update_properties">update_properties</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>